{"version":3,"file":"ContinuousLegend-fc7b1756.js","sources":["../../node_modules/d3-array/src/range.js","../../node_modules/d3-axis/src/identity.js","../../node_modules/d3-axis/src/axis.js","../../src/component/Legend/ContinuousLegend.tsx"],"sourcesContent":["export default function range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","export default function(x) {\n  return x;\n}\n","import identity from \"./identity.js\";\n\nvar top = 1,\n    right = 2,\n    bottom = 3,\n    left = 4,\n    epsilon = 1e-6;\n\nfunction translateX(x) {\n  return \"translate(\" + x + \",0)\";\n}\n\nfunction translateY(y) {\n  return \"translate(0,\" + y + \")\";\n}\n\nfunction number(scale) {\n  return d => +scale(d);\n}\n\nfunction center(scale, offset) {\n  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return d => +scale(d) + offset;\n}\n\nfunction entering() {\n  return !this.__axis;\n}\n\nfunction axis(orient, scale) {\n  var tickArguments = [],\n      tickValues = null,\n      tickFormat = null,\n      tickSizeInner = 6,\n      tickSizeOuter = 6,\n      tickPadding = 3,\n      offset = typeof window !== \"undefined\" && window.devicePixelRatio > 1 ? 0 : 0.5,\n      k = orient === top || orient === left ? -1 : 1,\n      x = orient === left || orient === right ? \"x\" : \"y\",\n      transform = orient === top || orient === bottom ? translateX : translateY;\n\n  function axis(context) {\n    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,\n        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n        range = scale.range(),\n        range0 = +range[0] + offset,\n        range1 = +range[range.length - 1] + offset,\n        position = (scale.bandwidth ? center : number)(scale.copy(), offset),\n        selection = context.selection ? context.selection() : context,\n        path = selection.selectAll(\".domain\").data([null]),\n        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n        tickExit = tick.exit(),\n        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n        line = tick.select(\"line\"),\n        text = tick.select(\"text\");\n\n    path = path.merge(path.enter().insert(\"path\", \".tick\")\n        .attr(\"class\", \"domain\")\n        .attr(\"stroke\", \"currentColor\"));\n\n    tick = tick.merge(tickEnter);\n\n    line = line.merge(tickEnter.append(\"line\")\n        .attr(\"stroke\", \"currentColor\")\n        .attr(x + \"2\", k * tickSizeInner));\n\n    text = text.merge(tickEnter.append(\"text\")\n        .attr(\"fill\", \"currentColor\")\n        .attr(x, k * spacing)\n        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\n    if (context !== selection) {\n      path = path.transition(context);\n      tick = tick.transition(context);\n      line = line.transition(context);\n      text = text.transition(context);\n\n      tickExit = tickExit.transition(context)\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute(\"transform\"); });\n\n      tickEnter\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });\n    }\n\n    tickExit.remove();\n\n    path\n        .attr(\"d\", orient === left || orient === right\n            ? (tickSizeOuter ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H\" + offset + \"V\" + range1 + \"H\" + k * tickSizeOuter : \"M\" + offset + \",\" + range0 + \"V\" + range1)\n            : (tickSizeOuter ? \"M\" + range0 + \",\" + k * tickSizeOuter + \"V\" + offset + \"H\" + range1 + \"V\" + k * tickSizeOuter : \"M\" + range0 + \",\" + offset + \"H\" + range1));\n\n    tick\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", function(d) { return transform(position(d) + offset); });\n\n    line\n        .attr(x + \"2\", k * tickSizeInner);\n\n    text\n        .attr(x, k * spacing)\n        .text(format);\n\n    selection.filter(entering)\n        .attr(\"fill\", \"none\")\n        .attr(\"font-size\", 10)\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\n    selection\n        .each(function() { this.__axis = position; });\n  }\n\n  axis.scale = function(_) {\n    return arguments.length ? (scale = _, axis) : scale;\n  };\n\n  axis.ticks = function() {\n    return tickArguments = Array.from(arguments), axis;\n  };\n\n  axis.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();\n  };\n\n  axis.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();\n  };\n\n  axis.tickFormat = function(_) {\n    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n  };\n\n  axis.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n  };\n\n  axis.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n  };\n\n  axis.offset = function(_) {\n    return arguments.length ? (offset = +_, axis) : offset;\n  };\n\n  return axis;\n}\n\nexport function axisTop(scale) {\n  return axis(top, scale);\n}\n\nexport function axisRight(scale) {\n  return axis(right, scale);\n}\n\nexport function axisBottom(scale) {\n  return axis(bottom, scale);\n}\n\nexport function axisLeft(scale) {\n  return axis(left, scale);\n}\n","import * as React from \"react\";\nimport { useRef } from \"react\";\n\nimport { select, scaleLinear, scaleSymlog, axisBottom, axisRight } from \"d3\";\n\nimport { color } from \"d3-color\";\nimport { range } from \"d3\";\n\nimport { d3ColorScales } from \"../Utils/d3ColorScale\";\nimport {\n  RGBToHex,\n  colorsArray,\n  getTickValues,\n} from \"../Utils/legendCommonFunction\";\nimport { colorTablesArray } from \"../colorTableTypes\";\nimport defaultColorTables from \"../color-tables.json\";\nimport { DEFAULT_STYLE } from \"./constants\";\n\nexport type ContinuousLegendProps = {\n  /**\n   * Min value\n   */\n  min?: number;\n  /**\n   * Max value\n   */\n  max?: number;\n  /**\n   * Title for the legend\n   */\n  dataObjectName?: string;\n  /**\n   * Name of the color(ex: Rainbow)\n   */\n  colorName?: string;\n  /**\n   * Orientation for legend\n   */\n  horizontal?: boolean | null;\n  /**\n   * Used while using color selector component\n   *\n   * Returns the object with name and array of colors\n   */\n  getColorScaleData?: any;\n  /**\n   * ID\n   */\n  id?: string;\n  /**\n   * Prop containing color table data\n   *\n   * Reference: https://github.com/emerson-eps/color-tables/blob/main/react-app/src/component/color-tables.json\n   */\n  colorTables?: colorTablesArray;\n  /**\n   * Optional function property\n   *\n   * Takes a value in the range [0,1] and returns a color\n   *\n   * If a colorMapFunction is used, then the colorTable file is not needed\n   */\n  colorMapFunction?: any;\n  /**\n   * Reverse the range(min and max)\n   */\n  reverseRange?: boolean;\n  isAuto?: boolean;\n  breakPoint?: any;\n  editedBreakPointValues?: any;\n  isLog?: boolean;\n  isNearest?: boolean;\n  /**\n   * Should the range be shown or not\n   */\n  isRangeShown?: boolean;\n  /**\n   * Font size of legend name (in px)\n   */\n  legendFontSize?: number;\n  /**\n   * Font size of legend ticks (in px)\n   */\n  tickFontSize?: number;\n  /**\n   * Number of ticks in the main legend (only shown when isRangeShown prop is true)\n   * This refers to the number between min and max range points\n   */\n  numberOfTicks?: number;\n  /**\n   * This prop controls the number of ticks shown on the scale of the color legend (in px)\n   */\n  legendScaleSize?: number;\n  /**\n   * apply css styles\n   */\n  cssLegendStyles?: React.CSSProperties;\n};\n\ndeclare type ItemColor = {\n  color: string;\n  breakPoint?: number;\n};\n\nexport const ContinuousLegend: React.FC<ContinuousLegendProps> = ({\n  min,\n  max,\n  dataObjectName,\n  colorName = \"Rainbow\",\n  horizontal,\n  getColorScaleData,\n  id,\n  colorTables = defaultColorTables as colorTablesArray,\n  colorMapFunction,\n  reverseRange = false,\n  breakPoint,\n  editedBreakPointValues,\n  isLog,\n  isNearest,\n  isRangeShown = true,\n  legendFontSize = 18,\n  tickFontSize = 12,\n  numberOfTicks = 3,\n  legendScaleSize = 200,\n  cssLegendStyles = DEFAULT_STYLE,\n}: ContinuousLegendProps) => {\n  const generateUniqueId = Math.ceil(Math.random() * 9999).toString();\n  const divRef = useRef<HTMLDivElement>(null);\n  React.useEffect(() => {\n    if (divRef.current) {\n      select(divRef.current).select(\"div\").remove();\n      select(divRef.current).select(\"svg\").remove();\n      continuousLegend();\n    }\n\n    async function continuousLegend() {\n      let itemColor: ItemColor[] = [];\n      let parsedColorTables;\n\n      try {\n        // fix for dash wrapper\n        if (typeof colorTables === \"string\") {\n          const res = await fetch(colorTables);\n          parsedColorTables = await res.json();\n        }\n        //Return the matched colors array from color.tables.json file\n        let legendColors =\n          typeof colorTables === \"string\"\n            ? colorsArray(colorName, parsedColorTables)\n            : colorsArray(colorName, colorTables);\n\n        const nearestData: any = [];\n\n        // Update color of legend based on color selector scales\n        // data is passed on click upon color scales\n        if (getColorScaleData && Object.keys(getColorScaleData).length > 0) {\n          // legend using color table data\n          if (getColorScaleData.color) {\n            legendColors = getColorScaleData.color;\n          }\n          // legend using d3 data\n          else if (getColorScaleData.arrayData) {\n            legendColors = getColorScaleData.arrayData;\n          }\n        }\n\n        const isD3Colors = d3ColorScales.find((value: any) => {\n          return value?.name === colorName;\n        });\n        // main continuous legend for d3 colors\n        if (isD3Colors && isD3Colors.discrete === false) {\n          const arrayData: any = [];\n          const d3ColorArrays = colorsArray(colorName, d3ColorScales);\n          const data = range(10).map(d => ({ color: d3ColorArrays(d / 10) }));\n          data.forEach((colorsObject: any, index: number) => {\n            arrayData.push([\n              0 + \".\" + index,\n              color(colorsObject.color)?.rgb().r,\n              color(colorsObject.color)?.rgb().g,\n              color(colorsObject.color)?.rgb().b,\n            ]);\n          });\n          legendColors = arrayData;\n        }\n\n        // condition to check if the legend is selected from color selector or not\n        const getColorTableScale = (\n          typeof colorTables === \"string\" ? parsedColorTables : colorTables\n        )?.find((value: any) => {\n          if (getColorScaleData) {\n            return value.name === getColorScaleData?.name;\n          } else {\n            return value.name === colorName;\n          }\n        });\n\n        const maxValue = legendColors.length - 1;\n\n        // condition for nearest interpolation\n        if (isNearest) {\n          const nColors = legendColors.length;\n          const delta = 1 / nColors;\n          let leftEnd = 0;\n          let rightEnd = 0 + delta;\n\n          legendColors.forEach((val: any) => {\n            nearestData.push(\n              {\n                breakPoint: Number(leftEnd.toFixed(2)),\n                color: RGBToHex([val[0], val[1], val[2], val[3]]).color,\n              },\n              {\n                breakPoint: Number(rightEnd.toFixed(2)),\n                color: RGBToHex([val[0], val[1], val[2], val[3]]).color,\n              }\n            );\n            leftEnd += delta;\n            rightEnd += delta;\n          });\n        }\n\n        // if colorMapFunction prop is passed\n        if (colorMapFunction) {\n          const rgbValue: any = [];\n          for (var i = 0; i <= 1; i += 0.05) {\n            const value = colorMapFunction(i);\n            rgbValue.push([i.toFixed(2), value[0], value[1], value[2]]);\n          }\n          legendColors = rgbValue;\n        }\n\n        const arrOfNum = breakPoint?.map((str: string) => {\n          return Number(str);\n        });\n\n        const userDefinedDomain = arrOfNum ? arrOfNum : [];\n        legendColors.forEach(\n          (value: [number, number, number, number], index: number) => {\n            let domainIndex;\n\n            if (userDefinedDomain[index]) {\n              domainIndex = userDefinedDomain[index];\n            } else {\n              domainIndex = value[0];\n            }\n\n            // return the color and breakPoint needed to draw the legend\n            itemColor.push({\n              // to support discrete color for continous data\n              breakPoint:\n                getColorTableScale?.discrete === true\n                  ? RGBToHex(value, maxValue).offset\n                  : breakPoint?.length > 0\n                  ? domainIndex * 100.0\n                  : value[0] * 100.0,\n              color: RGBToHex(value).color,\n            });\n          }\n        );\n\n        if (legendColors.length === 0) {\n          return [0, 0, 0];\n        }\n\n        // get the position and color from the breakpoint modal\n        // updates main legend onclicking the custom scales\n        if (\n          editedBreakPointValues?.colorArray?.length > 0 &&\n          editedBreakPointValues?.customizeFlag === true\n        ) {\n          const options = editedBreakPointValues.colorArray.map(function (\n            row: any\n          ) {\n            return { breakPoint: row.position * 100.0, color: row.color };\n          });\n\n          itemColor = options;\n        }\n\n        itemColor.sort((a, b) => {\n          return a.breakPoint - b.breakPoint;\n        });\n\n        //const colorScale = scaleSymlog().domain([min, max]).range([0, 150]);\n        // append a defs (for definition) element to your SVG\n        const svgLegend = select(divRef.current)\n          .style(\"margin-right\", \"2px\")\n          .style(\"margin-left\", \"2px\")\n          .append(\"svg\")\n          .style(\"cursor\", getColorScaleData ? \"pointer\" : \"auto\")\n          .style(\"border-radius\", \"5px\");\n\n        const defs = svgLegend.append(\"defs\");\n        svgLegend\n          .attr(\n            \"width\",\n            horizontal ? (legendScaleSize < 200 ? 200 : legendScaleSize) : \"100\"\n          )\n          .attr(\n            \"height\",\n            horizontal\n              ? \"70\"\n              : legendScaleSize < 200\n              ? 200\n              : legendScaleSize - 17\n          );\n        const currentIndex = \"linear-gradient-\" + id + \"0\";\n        const linearGradient = defs\n          .append(\"linearGradient\")\n          .attr(\"id\", currentIndex);\n        // append a linearGradient element to the defs and give it a unique id\n        if ((horizontal && !reverseRange) || (!horizontal && reverseRange)) {\n          linearGradient\n            .attr(\"x1\", \"0%\")\n            .attr(\"x2\", horizontal ? \"100%\" : \"0%\")\n            .attr(\"y1\", \"0%\")\n            .attr(\"y2\", horizontal ? \"0%\" : \"100%\");\n        } else if (\n          (!horizontal && !reverseRange) ||\n          (horizontal && reverseRange)\n        ) {\n          linearGradient\n            .attr(\"x1\", horizontal ? \"100%\" : \"0%\")\n            .attr(\"x2\", \"0%\")\n            .attr(\"y1\", horizontal ? \"0%\" : \"100%\")\n            .attr(\"y2\", \"0%\");\n        }\n        const colorScale = scaleLinear().domain([0, 1]).range([0, 400]);\n        // append multiple color stops by using D3's data/enter step\n        linearGradient\n          .selectAll(\"stop\")\n          .data(nearestData.length > 0 ? nearestData : itemColor)\n          .enter()\n          .append(\"stop\")\n          .attr(\"offset\", function (data: any) {\n            return nearestData.length > 0\n              ? colorScale(data.breakPoint) / 4 + \"%\"\n              : data.breakPoint + \"%\";\n          })\n          .attr(\"stop-color\", function (data: { color: any }) {\n            return data.color;\n          });\n\n        // draw the rectangle and fill with gradient\n        svgLegend\n          .append(\"rect\")\n          .attr(\"x\", 25)\n          .attr(\"y\", horizontal ? 30 : 18)\n          .attr(\n            \"width\",\n            horizontal\n              ? legendScaleSize < 200\n                ? 159\n                : legendScaleSize - 40\n              : 20\n          )\n          .attr(\n            \"height\",\n            horizontal ? 20 : legendScaleSize < 200 ? 159 : legendScaleSize - 40\n          )\n          .style(\"fill\", \"url(#\" + currentIndex + \")\");\n\n        // append title\n        svgLegend\n          .append(\"text\")\n          .attr(\"x\", horizontal ? 25 : -168)\n          .attr(\"y\", horizontal ? 20 : 15)\n          .style(\"text-anchor\", \"left\")\n          .style(\"transform\", horizontal ? \"none\" : \"left\")\n          .style(\"transform\", horizontal ? \"none\" : \"rotate(270deg)\")\n          .style(\"fill\", \"grey\")\n          .style(\n            \"font-size\",\n            legendFontSize && legendFontSize > 0\n              ? `${legendFontSize}px`\n              : \"16px\"\n          )\n          .text(dataObjectName);\n        // create tick marks\n        // range varies the size of the axis\n\n        const xLeg = (isLog ? scaleSymlog() : scaleLinear())\n          .domain(reverseRange ? [max, min] : [min, max])\n          /*@ts-ignore*/\n          .range([10, legendScaleSize < 200 ? 168 : legendScaleSize - 32]);\n        const yLeg = (isLog ? scaleSymlog() : scaleLinear())\n          .domain(reverseRange ? [min, max] : [max, min])\n          /*@ts-ignore*/\n          .range([10, legendScaleSize < 200 ? 168 : legendScaleSize - 32]);\n\n        const horizontalAxisLeg = axisBottom(xLeg).tickValues(\n          xLeg\n            .ticks(0)\n            .concat(xLeg.domain(), getTickValues(xLeg.domain(), numberOfTicks))\n        );\n        const VerticalAxisLeg = axisRight(yLeg).tickValues(\n          yLeg\n            .ticks(0)\n            .concat(yLeg.domain(), getTickValues(xLeg.domain(), numberOfTicks))\n        );\n\n        if (isRangeShown) {\n          svgLegend\n            .attr(\"class\", \"axis\")\n            .append(\"g\")\n            .attr(\n              \"transform\",\n              horizontal ? \"translate(16, 50)\" : \"translate(45, 7.5)\"\n            )\n            .style(\n              \"font-size\",\n              tickFontSize && tickFontSize > 0 ? `${tickFontSize}px` : \"12px\"\n            )\n            .style(\"font-weight\", \"700\")\n            .call(horizontal ? horizontalAxisLeg : VerticalAxisLeg)\n            .style(\"height\", 15);\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    min,\n    max,\n    colorName,\n    colorTables,\n    horizontal,\n    getColorScaleData,\n    colorMapFunction,\n    dataObjectName,\n    id,\n    reverseRange,\n    isLog,\n    isNearest,\n    isRangeShown,\n    legendFontSize,\n    tickFontSize,\n    numberOfTicks,\n    legendScaleSize,\n  ]);\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        minHeight: \"70px\",\n        zIndex: 999,\n        margin: \"10px\",\n        ...cssLegendStyles,\n      }}\n    >\n      <div\n        id={id ? id : `cont-legend - ${generateUniqueId}`}\n        ref={divRef}\n      ></div>\n    </div>\n  );\n};\n"],"names":["range","start","stop","step","n","i","identity","x","top","right","bottom","left","epsilon","translateX","translateY","y","number","scale","d","center","offset","entering","axis","orient","tickArguments","tickValues","tickFormat","tickSizeInner","tickSizeOuter","tickPadding","k","transform","context","values","format","spacing","range0","range1","position","selection","path","tick","tickExit","tickEnter","line","text","p","_","axisRight","axisBottom","ContinuousLegend","min","max","dataObjectName","colorName","horizontal","getColorScaleData","id","colorTables","defaultColorTables","colorMapFunction","reverseRange","breakPoint","editedBreakPointValues","isLog","isNearest","isRangeShown","legendFontSize","tickFontSize","numberOfTicks","legendScaleSize","cssLegendStyles","DEFAULT_STYLE","generateUniqueId","divRef","useRef","React.useEffect","select","continuousLegend","itemColor","parsedColorTables","legendColors","colorsArray","nearestData","isD3Colors","d3ColorScales","value","arrayData","d3ColorArrays","colorsObject","index","_a","color","_b","_c","getColorTableScale","maxValue","delta","leftEnd","rightEnd","val","RGBToHex","rgbValue","arrOfNum","str","userDefinedDomain","domainIndex","row","b","svgLegend","defs","currentIndex","linearGradient","colorScale","scaleLinear","data","xLeg","scaleSymlog","yLeg","horizontalAxisLeg","getTickValues","VerticalAxisLeg","error","jsx"],"mappings":"wMAAe,SAASA,GAAMC,EAAOC,EAAMC,EAAM,CAC/CF,EAAQ,CAACA,EAAOC,EAAO,CAACA,EAAMC,GAAQC,EAAI,UAAU,QAAU,GAAKF,EAAOD,EAAOA,EAAQ,EAAG,GAAKG,EAAI,EAAI,EAAI,CAACD,EAM9G,QAJIE,EAAI,GACJD,EAAI,KAAK,IAAI,EAAG,KAAK,MAAMF,EAAOD,GAASE,CAAI,CAAC,EAAI,EACpDH,EAAQ,IAAI,MAAMI,CAAC,EAEhB,EAAEC,EAAID,GACXJ,EAAMK,CAAC,EAAIJ,EAAQI,EAAIF,EAGzB,OAAOH,CACT,CCZe,SAAQM,GAACC,EAAG,CACzB,OAAOA,CACT,CCAA,IAAIC,EAAM,EACNC,EAAQ,EACRC,EAAS,EACTC,EAAO,EACPC,GAAU,KAEd,SAASC,GAAWN,EAAG,CACrB,MAAO,aAAeA,EAAI,KAC5B,CAEA,SAASO,GAAWC,EAAG,CACrB,MAAO,eAAiBA,EAAI,GAC9B,CAEA,SAASC,GAAOC,EAAO,CACrB,OAAOC,GAAK,CAACD,EAAMC,CAAC,CACtB,CAEA,SAASC,GAAOF,EAAOG,EAAQ,CAC7B,OAAAA,EAAS,KAAK,IAAI,EAAGH,EAAM,UAAS,EAAKG,EAAS,CAAC,EAAI,EACnDH,EAAM,UAASG,EAAS,KAAK,MAAMA,CAAM,GACtCF,GAAK,CAACD,EAAMC,CAAC,EAAIE,CAC1B,CAEA,SAASC,IAAW,CAClB,MAAO,CAAC,KAAK,MACf,CAEA,SAASC,GAAKC,EAAQN,EAAO,CAC3B,IAAIO,EAAgB,CAAE,EAClBC,EAAa,KACbC,EAAa,KACbC,EAAgB,EAChBC,EAAgB,EAChBC,EAAc,EACdT,EAAS,OAAO,OAAW,KAAe,OAAO,iBAAmB,EAAI,EAAI,GAC5EU,EAAIP,IAAWf,GAAOe,IAAWZ,EAAO,GAAK,EAC7CJ,EAAIgB,IAAWZ,GAAQY,IAAWd,EAAQ,IAAM,IAChDsB,EAAYR,IAAWf,GAAOe,IAAWb,EAASG,GAAaC,GAEnE,SAASQ,EAAKU,EAAS,CACrB,IAAIC,EAASR,IAAsBR,EAAM,MAAQA,EAAM,MAAM,MAAMA,EAAOO,CAAa,EAAIP,EAAM,OAAQ,GACrGiB,EAASR,IAAsBT,EAAM,WAAaA,EAAM,WAAW,MAAMA,EAAOO,CAAa,EAAIlB,IACjG6B,EAAU,KAAK,IAAIR,EAAe,CAAC,EAAIE,EACvC7B,EAAQiB,EAAM,MAAO,EACrBmB,EAAS,CAACpC,EAAM,CAAC,EAAIoB,EACrBiB,EAAS,CAACrC,EAAMA,EAAM,OAAS,CAAC,EAAIoB,EACpCkB,GAAYrB,EAAM,UAAYE,GAASH,IAAQC,EAAM,KAAM,EAAEG,CAAM,EACnEmB,EAAYP,EAAQ,UAAYA,EAAQ,UAAW,EAAGA,EACtDQ,EAAOD,EAAU,UAAU,SAAS,EAAE,KAAK,CAAC,IAAI,CAAC,EACjDE,EAAOF,EAAU,UAAU,OAAO,EAAE,KAAKN,EAAQhB,CAAK,EAAE,MAAO,EAC/DyB,EAAWD,EAAK,KAAM,EACtBE,EAAYF,EAAK,QAAQ,OAAO,GAAG,EAAE,KAAK,QAAS,MAAM,EACzDG,EAAOH,EAAK,OAAO,MAAM,EACzBI,EAAOJ,EAAK,OAAO,MAAM,EAE7BD,EAAOA,EAAK,MAAMA,EAAK,MAAK,EAAG,OAAO,OAAQ,OAAO,EAChD,KAAK,QAAS,QAAQ,EACtB,KAAK,SAAU,cAAc,CAAC,EAEnCC,EAAOA,EAAK,MAAME,CAAS,EAE3BC,EAAOA,EAAK,MAAMD,EAAU,OAAO,MAAM,EACpC,KAAK,SAAU,cAAc,EAC7B,KAAKpC,EAAI,IAAKuB,EAAIH,CAAa,CAAC,EAErCkB,EAAOA,EAAK,MAAMF,EAAU,OAAO,MAAM,EACpC,KAAK,OAAQ,cAAc,EAC3B,KAAKpC,EAAGuB,EAAIK,CAAO,EACnB,KAAK,KAAMZ,IAAWf,EAAM,MAAQe,IAAWb,EAAS,SAAW,QAAQ,CAAC,EAE7EsB,IAAYO,IACdC,EAAOA,EAAK,WAAWR,CAAO,EAC9BS,EAAOA,EAAK,WAAWT,CAAO,EAC9BY,EAAOA,EAAK,WAAWZ,CAAO,EAC9Ba,EAAOA,EAAK,WAAWb,CAAO,EAE9BU,EAAWA,EAAS,WAAWV,CAAO,EACjC,KAAK,UAAWpB,EAAO,EACvB,KAAK,YAAa,SAASM,EAAG,CAAE,OAAO,SAASA,EAAIoB,EAASpB,CAAC,CAAC,EAAIa,EAAUb,EAAIE,CAAM,EAAI,KAAK,aAAa,WAAW,CAAE,CAAE,EAEjIuB,EACK,KAAK,UAAW/B,EAAO,EACvB,KAAK,YAAa,SAASM,EAAG,CAAE,IAAI4B,EAAI,KAAK,WAAW,OAAQ,OAAOf,GAAWe,GAAK,SAASA,EAAIA,EAAE5B,CAAC,CAAC,EAAI4B,EAAIR,EAASpB,CAAC,GAAKE,CAAM,CAAI,CAAA,GAGhJsB,EAAS,OAAM,EAEfF,EACK,KAAK,IAAKjB,IAAWZ,GAAQY,IAAWd,EAClCmB,EAAgB,IAAME,EAAIF,EAAgB,IAAMQ,EAAS,IAAMhB,EAAS,IAAMiB,EAAS,IAAMP,EAAIF,EAAgB,IAAMR,EAAS,IAAMgB,EAAS,IAAMC,EACrJT,EAAgB,IAAMQ,EAAS,IAAMN,EAAIF,EAAgB,IAAMR,EAAS,IAAMiB,EAAS,IAAMP,EAAIF,EAAgB,IAAMQ,EAAS,IAAMhB,EAAS,IAAMiB,CAAO,EAEvKI,EACK,KAAK,UAAW,CAAC,EACjB,KAAK,YAAa,SAASvB,EAAG,CAAE,OAAOa,EAAUO,EAASpB,CAAC,EAAIE,CAAM,CAAI,CAAA,EAE9EwB,EACK,KAAKrC,EAAI,IAAKuB,EAAIH,CAAa,EAEpCkB,EACK,KAAKtC,EAAGuB,EAAIK,CAAO,EACnB,KAAKD,CAAM,EAEhBK,EAAU,OAAOlB,EAAQ,EACpB,KAAK,OAAQ,MAAM,EACnB,KAAK,YAAa,EAAE,EACpB,KAAK,cAAe,YAAY,EAChC,KAAK,cAAeE,IAAWd,EAAQ,QAAUc,IAAWZ,EAAO,MAAQ,QAAQ,EAExF4B,EACK,KAAK,UAAW,CAAE,KAAK,OAASD,CAAW,CAAA,CACjD,CAED,OAAAhB,EAAK,MAAQ,SAASyB,EAAG,CACvB,OAAO,UAAU,QAAU9B,EAAQ8B,EAAGzB,GAAQL,CAClD,EAEEK,EAAK,MAAQ,UAAW,CACtB,OAAOE,EAAgB,MAAM,KAAK,SAAS,EAAGF,CAClD,EAEEA,EAAK,cAAgB,SAASyB,EAAG,CAC/B,OAAO,UAAU,QAAUvB,EAAgBuB,GAAK,KAAO,CAAE,EAAG,MAAM,KAAKA,CAAC,EAAGzB,GAAQE,EAAc,MAAK,CAC1G,EAEEF,EAAK,WAAa,SAASyB,EAAG,CAC5B,OAAO,UAAU,QAAUtB,EAAasB,GAAK,KAAO,KAAO,MAAM,KAAKA,CAAC,EAAGzB,GAAQG,GAAcA,EAAW,MAAK,CACpH,EAEEH,EAAK,WAAa,SAASyB,EAAG,CAC5B,OAAO,UAAU,QAAUrB,EAAaqB,EAAGzB,GAAQI,CACvD,EAEEJ,EAAK,SAAW,SAASyB,EAAG,CAC1B,OAAO,UAAU,QAAUpB,EAAgBC,EAAgB,CAACmB,EAAGzB,GAAQK,CAC3E,EAEEL,EAAK,cAAgB,SAASyB,EAAG,CAC/B,OAAO,UAAU,QAAUpB,EAAgB,CAACoB,EAAGzB,GAAQK,CAC3D,EAEEL,EAAK,cAAgB,SAASyB,EAAG,CAC/B,OAAO,UAAU,QAAUnB,EAAgB,CAACmB,EAAGzB,GAAQM,CAC3D,EAEEN,EAAK,YAAc,SAASyB,EAAG,CAC7B,OAAO,UAAU,QAAUlB,EAAc,CAACkB,EAAGzB,GAAQO,CACzD,EAEEP,EAAK,OAAS,SAASyB,EAAG,CACxB,OAAO,UAAU,QAAU3B,EAAS,CAAC2B,EAAGzB,GAAQF,CACpD,EAESE,CACT,CAMO,SAAS0B,GAAU/B,EAAO,CAC/B,OAAOK,GAAKb,EAAOQ,CAAK,CAC1B,CAEO,SAASgC,GAAWhC,EAAO,CAChC,OAAOK,GAAKZ,EAAQO,CAAK,CAC3B,CCjEO,MAAAiC,GAAA,CAAA,CAA2D,IAAAC,EAChE,IAAAC,EACA,eAAAC,EACA,UAAAC,EAAA,UACY,WAAAC,EACZ,kBAAAC,EACA,GAAAC,EACAC,YAAAA,EAAAC,GACc,iBAAAC,EACd,aAAAC,EAAA,GACe,WAAAC,EACf,uBAAAC,EACA,MAAAC,EACA,UAAAC,EACA,aAAAC,EAAA,GACe,eAAAC,EAAA,GACE,aAAAC,EAAA,GACF,cAAAC,EAAA,EACC,gBAAAC,EAAA,IACE,gBAAAC,EAAAC,EAEpB,IAAA,CACE,MAAAC,EAAA,KAAA,KAAA,KAAA,SAAA,IAAA,EAAA,WACAC,EAAAC,UAAA,IAAA,EACAC,OAAAA,GAAAA,UAAA,IAAA,CACEF,EAAA,UACEG,EAAAH,EAAA,OAAA,EAAA,OAAA,KAAA,EAAA,SACAG,EAAAH,EAAA,OAAA,EAAA,OAAA,KAAA,EAAA,SACAI,KAGF,eAAAA,GAAA,SACE,IAAAC,EAAA,CAAA,EACAC,EAEA,GAAA,CAEE,OAAAtB,GAAA,WAEEsB,EAAA,MADA,MAAA,MAAAtB,CAAA,GACA,QAGF,IAAAuB,EAAA,OAAAvB,GAAA,SAAAwB,EAAA5B,EAAA0B,CAAA,EAAAE,EAAA5B,EAAAI,CAAA,EAKA,MAAAyB,EAAA,CAAA,EAIA3B,GAAA,OAAA,KAAAA,CAAA,EAAA,OAAA,IAEEA,EAAA,MACEyB,EAAAzB,EAAA,MAAiCA,EAAA,YAIjCyB,EAAAzB,EAAA,YAIJ,MAAA4B,EAAAC,GAAA,KAAAC,IACEA,GAAA,YAAAA,EAAA,QAAAhC,CAAuB,EAGzB,GAAA8B,GAAAA,EAAA,WAAA,GAAA,CACE,MAAAG,EAAA,CAAA,EACAC,EAAAN,EAAA5B,EAAA+B,EAAA,EACArF,GAAA,EAAA,EAAA,IAAAkB,IAAA,CAAA,MAAAsE,EAAAtE,EAAA,EAAA,CAAA,EAAA,EACA,QAAA,CAAAuE,EAAAC,IAAA,aACEH,EAAA,KAAA,CAAe,KAAAG,GACHC,EAAAC,EAAAH,EAAA,KAAA,IAAA,YAAAE,EAAA,MAAA,GACuBE,GAAAD,EAAAH,EAAA,KAAA,IAAA,YAAAI,GAAA,MAAA,GACAC,GAAAF,EAAAH,EAAA,KAAA,IAAA,YAAAK,GAAA,MAAA,CACA,CAAA,CAClC,CAAA,EAEHb,EAAAM,CAAe,CAIjB,MAAAQ,GAAAJ,EAAA,OAAAjC,GAAA,SAAAsB,EAAAtB,IAAA,YAAAiC,EAAA,KAAAL,GAGE9B,EACE8B,EAAA,QAAA9B,GAAA,YAAAA,EAAA,MAEA8B,EAAA,OAAAhC,GAIJ0C,GAAAf,EAAA,OAAA,EAGA,GAAAhB,EAAA,CAEE,MAAAgC,EAAA,EADAhB,EAAA,OAEA,IAAAiB,EAAA,EACAC,EAAA,EAAAF,EAEAhB,EAAA,QAAAmB,GAAA,CACEjB,EAAA,KAAY,CACV,WAAA,OAAAe,EAAA,QAAA,CAAA,CAAA,EACuC,MAAAG,EAAA,CAAAD,EAAA,CAAA,EAAAA,EAAA,CAAA,EAAAA,EAAA,CAAA,EAAAA,EAAA,CAAA,CAAA,CAAA,EAAA,KACa,EACpD,CACA,WAAA,OAAAD,EAAA,QAAA,CAAA,CAAA,EACwC,MAAAE,EAAA,CAAAD,EAAA,CAAA,EAAAA,EAAA,CAAA,EAAAA,EAAA,CAAA,EAAAA,EAAA,CAAA,CAAA,CAAA,EAAA,KACY,CACpD,EAEFF,GAAAD,EACAE,GAAAF,CAAY,CAAA,CACb,CAIH,GAAArC,EAAA,CACE,MAAA0C,EAAA,CAAA,EACA,QAAAjG,EAAA,EAAAA,GAAA,EAAAA,GAAA,IAAA,CACE,MAAAiF,EAAA1B,EAAAvD,CAAA,EACAiG,EAAA,KAAA,CAAAjG,EAAA,QAAA,CAAA,EAAAiF,EAAA,CAAA,EAAAA,EAAA,CAAA,EAAAA,EAAA,CAAA,CAAA,CAAA,CAA0D,CAE5DL,EAAAqB,CAAe,CAGjB,MAAAC,EAAAzC,GAAA,YAAAA,EAAA,IAAA0C,GACE,OAAAA,CAAA,GAGFC,EAAAF,GAAA,GAyBA,GAxBAtB,EAAA,QAAa,CAAAK,EAAAI,IAAA,CAET,IAAAgB,EAEAD,EAAAf,CAAA,EACEgB,EAAAD,EAAAf,CAAA,EAEAgB,EAAApB,EAAA,CAAA,EAIFP,EAAA,KAAA,CAAe,YAAAgB,GAAA,YAAAA,EAAA,YAAA,GAAAM,EAAAf,EAAAU,EAAA,EAAA,QAAAlC,GAAA,YAAAA,EAAA,QAAA,EAAA4C,EAAA,IAAApB,EAAA,CAAA,EAAA,IAOI,MAAAe,EAAAf,CAAA,EAAA,KACM,CAAA,CACxB,CACH,EAGFL,EAAA,SAAA,EACE,MAAA,CAAA,EAAA,EAAA,CAAA,IAKFY,EAAA9B,GAAA,YAAAA,EAAA,aAAA,YAAA8B,EAAA,QAAA,IAAA9B,GAAA,YAAAA,EAAA,iBAAA,KAUEgB,EANAhB,EAAA,WAAA,IAAA,SAAA4C,EAAA,CAGE,MAAA,CAAA,WAAAA,EAAA,SAAA,IAAA,MAAAA,EAAA,MAA4D,CAAA,GAMhE5B,EAAA,KAAA,CAAA,EAAA6B,IACE,EAAA,WAAAA,EAAA,UAAwB,EAK1B,MAAAC,EAAAhC,EAAAH,EAAA,OAAA,EAAA,MAAA,eAAA,KAAA,EAAA,MAAA,cAAA,KAAA,EAAA,OAAA,KAAA,EAAA,MAAA,SAAAlB,EAAA,UAAA,MAAA,EAAA,MAAA,gBAAA,KAAA,EAOAsD,GAAAD,EAAA,OAAA,MAAA,EACAA,EAAA,KACG,QACCtD,EAAAe,EAAA,IAAA,IAAAA,EAAA,KAC+D,EAAA,KAEhE,SACCf,EAAA,KAAAe,EAAA,IAAA,IAAAA,EAAA,EAKsB,EAE1B,MAAAyC,EAAA,mBAAAtD,EAAA,IACAuD,EAAAF,GAAA,OAAA,gBAAA,EAAA,KAAA,KAAAC,CAAA,EAIAxD,GAAA,CAAAM,GAAA,CAAAN,GAAAM,EACEmD,EAAA,KAAA,KAAA,IAAA,EAAA,KAAA,KAAAzD,EAAA,OAAA,IAAA,EAAA,KAAA,KAAA,IAAA,EAAA,KAAA,KAAAA,EAAA,KAAA,MAAA,GAIwC,CAAAA,GAAA,CAAAM,GAAAN,GAAAM,IAKxCmD,EAAA,KAAA,KAAAzD,EAAA,OAAA,IAAA,EAAA,KAAA,KAAA,IAAA,EAAA,KAAA,KAAAA,EAAA,KAAA,MAAA,EAAA,KAAA,KAAA,IAAA,EAMF,MAAA0D,GAAAC,IAAA,OAAA,CAAA,EAAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,GAAA,CAAA,EAEAF,EAAA,UAAA,MAAA,EAAA,KAAA7B,EAAA,OAAA,EAAAA,EAAAJ,CAAA,EAAA,MAAA,EAAA,OAAA,MAAA,EAAA,KAAA,SAAA,SAAAoC,EAAA,CAMI,OAAAhC,EAAA,OAAA,EAAA8B,GAAAE,EAAA,UAAA,EAAA,EAAA,IAAAA,EAAA,WAAA,GAEsB,CAAA,EAAA,KAAA,aAAA,SAAAA,EAAA,CAGtB,OAAAA,EAAA,KAAY,CAAA,EAIhBN,EAAA,OAAA,MAAA,EAAA,KAAA,IAAA,EAAA,EAAA,KAAA,IAAAtD,EAAA,GAAA,EAAA,EAAA,KAIG,QACCA,EAAAe,EAAA,IAAA,IAAAA,EAAA,GAAA,EAKI,EAAA,KAEL,SACCf,EAAA,GAAAe,EAAA,IAAA,IAAAA,EAAA,EACkE,EAAA,MAAA,OAAA,QAAAyC,EAAA,GAAA,EAKtEF,EAAA,OAAA,MAAA,EAAA,KAAA,IAAAtD,EAAA,GAAA,IAAA,EAAA,KAAA,IAAAA,EAAA,GAAA,EAAA,EAAA,MAAA,cAAA,MAAA,EAAA,MAAA,YAAAA,EAAA,OAAA,MAAA,EAAA,MAAA,YAAAA,EAAA,OAAA,gBAAA,EAAA,MAAA,OAAA,MAAA,EAAA,MAQG,YACCY,GAAAA,EAAA,EAAA,GAAAA,CAAA,KAAA,MAGI,EAAA,KAAAd,CAAA,EAMR,MAAA+D,GAAApD,EAAAqD,KAAAH,KAAA,OAAArD,EAAA,CAAAT,EAAAD,CAAA,EAAA,CAAAA,EAAAC,CAAA,CAAA,EAAA,MAAA,CAAA,GAAAkB,EAAA,IAAA,IAAAA,EAAA,EAAA,CAAA,EAIAgD,GAAAtD,EAAAqD,KAAAH,KAAA,OAAArD,EAAA,CAAAV,EAAAC,CAAA,EAAA,CAAAA,EAAAD,CAAA,CAAA,EAAA,MAAA,CAAA,GAAAmB,EAAA,IAAA,IAAAA,EAAA,EAAA,CAAA,EAKAiD,GAAAtE,GAAAmE,CAAA,EAAA,WAA2CA,EAAA,MAAA,CAAA,EAAA,OAAAA,EAAA,OAAA,EAAAI,GAAAJ,EAAA,OAAA,EAAA/C,CAAA,CAAA,CAG2B,EAEtEoD,GAAAzE,GAAAsE,CAAA,EAAA,WAAwCA,EAAA,MAAA,CAAA,EAAA,OAAAA,EAAA,OAAA,EAAAE,GAAAJ,EAAA,OAAA,EAAA/C,CAAA,CAAA,CAG8B,EAGtEH,GACE2C,EAAA,KAAA,QAAA,MAAA,EAAA,OAAA,GAAA,EAAA,KAGG,YACCtD,EAAA,oBAAA,oBACmC,EAAA,MAEpC,YACCa,GAAAA,EAAA,EAAA,GAAAA,CAAA,KAAA,MACyD,EAAA,MAAA,cAAA,KAAA,EAAA,KAAAb,EAAAgE,GAAAE,EAAA,EAAA,MAAA,SAAA,EAAA,CAK/D,OAAAC,EAAA,CAEA,QAAA,MAAAA,CAAA,CAAmB,CACrB,CACF,EAAA,CAECvE,EACDC,EACAE,EACAI,EACAH,EACAC,EACAI,EACAP,EACAI,EACAI,EACAG,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,CACA,CAAA,EAEFqD,GACE,MAAC,CAAA,MAAA,CACQ,SAAA,WACK,UAAA,OACC,OAAA,IACH,OAAA,OACA,GAAApD,CACL,EACL,SAAAoD,GAEA,MAAC,CAAA,GAAAlE,GAAA,iBAAAgB,CAAA,GACgD,IAAAC,CAC1C,CAAA,CACN,CAAA,CAGP;;;;;;;;;;;;;;","x_google_ignoreList":[0,1,2]}